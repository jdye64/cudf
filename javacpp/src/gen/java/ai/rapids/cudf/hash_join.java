// Targeted by JavaCPP version 1.5.4: DO NOT EDIT THIS FILE

package ai.rapids.cudf;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static ai.rapids.cudf.global.cudf.*;


/**
 * \brief Hash join that builds hash table in creation and probes results in subsequent {@code *_join}
 * member functions.
 *
 * This class enables the hash join scheme that builds hash table once, and probes as many times as
 * needed (possibly in parallel).
 */
@Namespace("cudf") @NoOffset @Properties(inherit = ai.rapids.cudf.presets.Cudf.class)
public class hash_join extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public hash_join(Pointer p) { super(p); }

  
  
  
  
  

  /**
   * \brief Construct a hash join object for subsequent probe calls.
   *
   * \note The {@code hash_join} object must not outlive the table viewed by {@code build}, else behavior is
   * undefined.
   *
   * @param build The build table, from which the hash table is built.
   * @param build_on The column indices from {@code build} to join on.
   * @param stream CUDA stream used for device memory operations and kernel launches
   */
  public hash_join(@Const @ByRef table_view build,
              @StdVector size_type build_on,
              @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream) { super((Pointer)null); allocate(build, build_on, stream); }
  private native void allocate(@Const @ByRef table_view build,
              @StdVector size_type build_on,
              @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream);
  public hash_join(@Const @ByRef table_view build,
              @StdVector size_type build_on) { super((Pointer)null); allocate(build, build_on); }
  private native void allocate(@Const @ByRef table_view build,
              @StdVector size_type build_on);

  /**
   * \brief Controls where common columns will be output for a inner join.
   */
  public enum common_columns_output_side {
    /** Common columns is output in the probe portion of the table pair returned by
 *  {@code inner_join}. */
    PROBE(0),
    /** Common columns is output in the build portion of the table pair returned by
 *  {@code inner_join}. */
    BUILD(1);

      public final int value;
      private common_columns_output_side(int v) { this.value = v; }
      private common_columns_output_side(common_columns_output_side e) { this.value = e.value; }
      public common_columns_output_side intern() { for (common_columns_output_side e : values()) if (e.value == value) return e; return this; }
      @Override public String toString() { return intern().name(); }
  }

  /**
   * \brief Performs an inner join by probing in the internal hash table.
   *
   * Given that it is sometimes desired to choose the small table to be the {@code build} side for an
   * inner joinï¼Œa ({@code probe}, {@code build}) table pair, which contains the probe and build portions of the
   * logical joined table respectively, is returned so that caller can freely rearrange them to
   * restore the logical {@code left} {@code right} order. This introduces some extra logic about where "common"
   * columns should go, i.e. the legacy {@code cudf::inner_join()} API always outputs "common" columns in
   * the {@code left} portion and the corresponding columns in the {@code right} portion are omitted. To better
   * align with the legacy {@code cudf::inner_join()} API, a {@code common_columns_output_side} parameter is
   * introduced to specify whether "common" columns should go in {@code probe} or {@code build} portion.
   *
   * More details please @see cudf::inner_join().
   *
   * @param probe The probe table, from which the tuples are probed.
   * @param probe_on The column indices from {@code probe} to join on.
   * @param columns_in_common is a vector of pairs of column indices into
   * {@code probe} and {@code build}, respectively, that are "in common". For "common"
   * columns, only a single output column will be produced, which is gathered
   * from {@code probe_on} columns or {@code build_on} columns if {@code probe_output_side} is LEFT or RIGHT.
   * Else, for every column in {@code probe_on} and {@code build_on},
   * an output column will be produced. For each of these pairs (P, B), P
   * should exist in {@code probe_on} and B should exist in {@code build_on}.
   * @param common_columns_output_side @see {@code common_columns_output_side}.
   * @param compare_nulls Controls whether null join-key values should match or not.
   * @param mr Device memory resource used to allocate the returned table and columns' device
   * memory.
   * @param stream CUDA stream used for device memory operations and kernel launches
   *
   * @return Table pair of ({@code probe}, {@code build}) of joining both tables on the columns
   * specified by {@code probe_on} and {@code build_on}. The resulting table pair will be joined columns of
   * ({@code probe(including common columns)}, {@code build(excluding common columns)}) if
   * {@code common_columns_output_side} is {@code PROBE}, or ({@code probe(excluding common columns)},
   * {@code build(including common columns)}) if {@code common_columns_output_side} is {@code BUILD}.
   */
  public native @ByVal std::pair<std::unique_ptr<cudf::table>,std::unique_ptr<cudf::table> > inner_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common,
      common_columns_output_side common_columns_output_side/*=cudf::hash_join::common_columns_output_side::PROBE*/,
      @ByVal(nullValue = "null_equality::EQUAL") null_equality compare_nulls,
      @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream,
      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
  public native @ByVal std::pair<std::unique_ptr<cudf::table>,std::unique_ptr<cudf::table> > inner_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common);
  public native @ByVal std::pair<std::unique_ptr<cudf::table>,std::unique_ptr<cudf::table> > inner_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common,
      @Cast("cudf::hash_join::common_columns_output_side") int common_columns_output_side/*=cudf::hash_join::common_columns_output_side::PROBE*/,
      @ByVal(nullValue = "null_equality::EQUAL") null_equality compare_nulls,
      @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream,
      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);

  /**
   * \brief Performs a left join by probing in the internal hash table.
   *
   * More details please @see cudf::left_join().
   *
   * @param probe The probe table, from which the tuples are probed.
   * @param probe_on The column indices from {@code probe} to join on.
   * @param columns_in_common is a vector of pairs of column indices into
   * {@code probe} and {@code build}, respectively, that are "in common". For "common"
   * columns, only a single output column will be produced, which is gathered
   * from {@code probe_on} columns. Else, for every column in {@code probe_on} and {@code build_on},
   * an output column will be produced. For each of these pairs (P, B), P
   * should exist in {@code probe_on} and B should exist in {@code build_on}.
   * @param compare_nulls Controls whether null join-key values should match or not.
   * @param mr Device memory resource used to allocate the returned table and columns' device
   * memory.
   * @param stream CUDA stream used for device memory operations and kernel launches
   *
   * @return Result of joining {@code build} and {@code probe} tables on the columns
   * specified by {@code build_on} and {@code probe_on}. The resulting table will be joined columns of
   * {@code probe(including common columns)+build(excluding common columns)}.
   */
  public native @UniquePtr table left_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common,
      @ByVal(nullValue = "null_equality::EQUAL") null_equality compare_nulls,
      @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream,
      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
  public native @UniquePtr table left_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common);

  /**
   * \brief Performs a full join by probing in the internal hash table.
   *
   * More details please @see cudf::full_join().
   *
   * @param probe The probe table, from which the tuples are probed.
   * @param probe_on The column indices from {@code probe} to join on.
   * @param columns_in_common is a vector of pairs of column indices into
   * {@code probe} and {@code build}, respectively, that are "in common". For "common"
   * columns, only a single output column will be produced, which is gathered
   * from {@code probe_on} columns. Else, for every column in {@code probe_on} and {@code build_on},
   * an output column will be produced. For each of these pairs (P, B), P
   * should exist in {@code probe_on} and B should exist in {@code build_on}.
   * @param compare_nulls Controls whether null join-key values should match or not.
   * @param mr Device memory resource used to allocate the returned table and columns' device
   * memory.
   * @param stream CUDA stream used for device memory operations and kernel launches
   *
   * @return Result of joining {@code build} and {@code probe} tables on the columns
   * specified by {@code build_on} and {@code probe_on}. The resulting table will be joined columns of
   * {@code probe(including common columns)+build(excluding common columns)}.
   */
  public native @UniquePtr table full_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common,
      @ByVal(nullValue = "null_equality::EQUAL") null_equality compare_nulls,
      @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") CudaStreamView stream,
      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
  public native @UniquePtr table full_join(
      @Const @ByRef table_view probe,
      @StdVector size_type probe_on,
      @StdVector std::pair<cudf::size_type,cudf::size_type> columns_in_common);
}
