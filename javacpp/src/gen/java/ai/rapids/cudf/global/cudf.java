// Targeted by JavaCPP version 1.5.4: DO NOT EDIT THIS FILE

package ai.rapids.cudf.global;

import ai.rapids.cudf.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import ai.rapids.thrust.*;
import static ai.rapids.cudf.global.thrust.*;
import ai.rapids.rmm.*;
import static ai.rapids.cudf.global.rmm.*;

public class cudf extends ai.rapids.cudf.presets.cudf {
    static { Loader.load(); }

// Targeting ../VectorUniqueColumnPointer.java


// Targeting ../PairColumnTableView.java


// Parsed from cudf/aggregation.hpp

/*
 * Copyright (c) 2019-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.hpp>

// #include <functional>
// #include <memory>
// #include <vector>

/**
 * \file aggregation.hpp
 * \brief Representation for specifying desired aggregations from
 * aggregation-based APIs, e.g., groupby, reductions, rolling, etc.
 *
 * \note Not all aggregation APIs support all aggregation operations. See
 * individual function documentation to see what aggregations are supported.
 */
// Targeting ../aggregation.java



@Namespace("cudf") public enum udf_type { CUDA(0 != 0), PTX(1 != 0);

    public final boolean value;
    private udf_type(boolean v) { this.value = v; }
    private udf_type(udf_type e) { this.value = e.value; }
    public udf_type intern() { for (udf_type e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/** Factory to create a SUM aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_sum_aggregation();

/** Factory to create a PRODUCT aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_product_aggregation();

/** Factory to create a MIN aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_min_aggregation();

/** Factory to create a MAX aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_max_aggregation();

/**
 * \brief Factory to create a COUNT aggregation
 *
 * @param null_handling Indicates if null values will be counted.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_count_aggregation(
  @ByVal(nullValue = "null_policy::EXCLUDE") null_policy null_handling);
@Namespace("cudf") public static native @UniquePtr aggregation make_count_aggregation();

/** Factory to create a ANY aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_any_aggregation();

/** Factory to create a ALL aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_all_aggregation();

/** Factory to create a SUM_OF_SQUARES aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_sum_of_squares_aggregation();

/** Factory to create a MEAN aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_mean_aggregation();

/**
 * \brief Factory to create a VARIANCE aggregation
 *
 * @param ddof Delta degrees of freedom. The divisor used in calculation of
 *             {@code variance} is {@code N - ddof}, where {@code N} is the population size.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_variance_aggregation(@ByVal(nullValue = "cudf::size_type(1)") IntPointer ddof);
@Namespace("cudf") public static native @UniquePtr aggregation make_variance_aggregation();

/**
 * \brief Factory to create a STD aggregation
 *
 * @param ddof Delta degrees of freedom. The divisor used in calculation of
 *             {@code std} is {@code N - ddof}, where {@code N} is the population size.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_std_aggregation(@ByVal(nullValue = "cudf::size_type(1)") IntPointer ddof);
@Namespace("cudf") public static native @UniquePtr aggregation make_std_aggregation();

/** Factory to create a MEDIAN aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_median_aggregation();

/**
 * \brief Factory to create a QUANTILE aggregation
 *
 * @param quantiles The desired quantiles
 * @param interpolation The desired interpolation
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector DoublePointer q,
                                                       @ByVal(nullValue = "interpolation::LINEAR") interpolation i);
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector DoublePointer q);
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector DoubleBuffer q,
                                                       @ByVal(nullValue = "interpolation::LINEAR") interpolation i);
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector DoubleBuffer q);
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector double[] q,
                                                       @ByVal(nullValue = "interpolation::LINEAR") interpolation i);
@Namespace("cudf") public static native @UniquePtr aggregation make_quantile_aggregation(@StdVector double[] q);

/**
 * \brief Factory to create an {@code argmax} aggregation
 *
 * {@code argmax} returns the index of the maximum element.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_argmax_aggregation();

/**
 * \brief Factory to create an {@code argmin} aggregation
 *
 * {@code argmin} returns the index of the minimum element.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_argmin_aggregation();

/**
 * \brief Factory to create a {@code nunique} aggregation
 *
 * {@code nunique} returns the number of unique elements.
 * @param null_handling Indicates if null values will be counted.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_nunique_aggregation(
  @ByVal(nullValue = "null_policy::EXCLUDE") null_policy null_handling);
@Namespace("cudf") public static native @UniquePtr aggregation make_nunique_aggregation();

/**
 * \brief Factory to create a {@code nth_element} aggregation
 *
 * {@code nth_element} returns the n'th element of the group/series.
 *
 * If \p n is not within the range {@code [-group_size, group_size)}, the result of
 * the respective group will be null. Negative indices {@code [-group_size, -1]}
 * corresponds to {@code [0, group_size-1]} indices respectively where {@code group_size} is
 * the size of each group.
 *
 * @param n index of nth element in each group.
 * @param null_handling Indicates to include/exclude nulls during indexing.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_nth_element_aggregation(
  @ByVal IntPointer n, @ByVal(nullValue = "null_policy::INCLUDE") null_policy null_handling);
@Namespace("cudf") public static native @UniquePtr aggregation make_nth_element_aggregation(
  @ByVal IntPointer n);

/** Factory to create a ROW_NUMBER aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_row_number_aggregation();

/** Factory to create a COLLECT_NUMBER aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_collect_aggregation();

/** Factory to create a LAG aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_lag_aggregation(@ByVal IntPointer offset);

/** Factory to create a LEAD aggregation */
@Namespace("cudf") public static native @UniquePtr aggregation make_lead_aggregation(@ByVal IntPointer offset);

/**
 * \brief Factory to create an aggregation base on UDF for PTX or CUDA
 *
 * @param type [in] : either udf_type::PTX or udf_type::CUDA
 * @param user_defined_aggregator [in] A string containing the aggregator code
 * @param output_type [in] expected output type
 *
 * @return aggregation unique pointer housing user_defined_aggregator string.
 */
@Namespace("cudf") public static native @UniquePtr aggregation make_udf_aggregation(udf_type type,
                                                  @StdString BytePointer user_defined_aggregator,
                                                  @ByVal data_type output_type);
@Namespace("cudf") public static native @UniquePtr aggregation make_udf_aggregation(@Cast("cudf::udf_type") boolean type,
                                                  @StdString String user_defined_aggregator,
                                                  @ByVal data_type output_type);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/concatenate.hpp

/*
 * Copyright (c) 2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/column/column_view.hpp>
// #include <cudf/table/table_view.hpp>

// #include <memory>
// #include <vector>
/**
 * \addtogroup copy_concatenate
 * \{
 * \file
 * \brief Concatenate columns APIs
 */

/**
 * \brief Concatenates {@code views[i]}'s bitmask from the bits
 * {@code [views[i].offset(), views[i].offset() + views[i].size())} for all elements
 * views[i] in views into a {@code device_buffer}
 *
 * Returns empty {@code device_buffer} if the column is not nullable
 *
 * @param views Vector of column views whose bitmask will to be concatenated
 * @param mr Device memory resource used for allocating the new device_buffer
 * @return rmm::device_buffer A {@code device_buffer} containing the bitmasks of all
 * the column views in the views vector
 */
@Namespace("cudf") public static native @ByVal device_buffer concatenate_masks(
  @StdVector column_view views,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @ByVal device_buffer concatenate_masks(
  @StdVector column_view views);

/**
 * \brief Concatenates multiple columns into a single column.
 *
 * @throws cudf::logic_error
 * If types of the input columns mismatch
 *
 * @param columns_to_concat The column views to be concatenated into a single
 * column
 * @param mr Device memory resource used to allocate the returned column's device memory.
 * @return Unique pointer to a single table having all the rows from the
 * elements of {@code columns_to_concat} respectively in the same order.
 */
@Namespace("cudf") public static native @UniquePtr column concatenate(
  @StdVector column_view columns_to_concat,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr column concatenate(
  @StdVector column_view columns_to_concat);

/**
 * \brief Columns of {@code tables_to_concat} are concatenated vertically to return a
 * single table_view
 *
 * \ingroup column_concatenate
 *
 * example:
 * <pre>{@code
 * column_view c0; //Contains {0,1,2,3}
 * column_view c1; //Contains {4,5,6,7}
 * table_view t0{{c0, c0}};
 * table_view t1{{c1, c1}};
 * ...
 * auto t = concatenate({t0.view(), t1.view()});
 * column_view tc0 = (t->view()).column(0); //Contains {0,1,2,3,4,5,6,7}
 * column_view tc1 = (t->view()).column(1); //Contains {0,1,2,3,4,5,6,7}
 * }</pre>
 *
 * @throws cudf::logic_error
 * If number of columns mismatch
 *
 * @param tables_to_concat The table views to be concatenated into a single
 * table
 * @param mr Device memory resource used to allocate the returned table's device memory.
 * @return Unique pointer to a single table having all the rows from the
 * elements of {@code tables_to_concat} respectively in the same order.
 */
@Namespace("cudf") public static native @UniquePtr table concatenate(
  @StdVector table_view tables_to_concat,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr table concatenate(
  @StdVector table_view tables_to_concat);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/datetime.hpp

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.hpp>

// #include <memory>

/**
 * \file datetime.hpp
 * \brief DateTime column APIs.
 */
/**
 * \addtogroup datetime_extract
 * \{
 * \file
 */

/**
 * \brief  Extracts year from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t years
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_year(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_year(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts month from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t months
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_month(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_month(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts day from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t days
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_day(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_day(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts day from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t days
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_weekday(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_weekday(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts hour from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t hours
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_hour(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_hour(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts minute from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t minutes
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_minute(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_minute(
  @Const @ByRef column_view column);

/**
 * \brief  Extracts second from any date time type and returns an int16_t
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of the extracted int16_t seconds
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_second(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column extract_second(
  @Const @ByRef column_view column);

/** \} */  // end of group
/**
 * \addtogroup datetime_compute
 * \{
 * \file
 */

/**
 * \brief  Computes the last day of the month in date time type and returns a TIMESTAMP_DAYS
 * cudf::column.
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column containing last day of the month as TIMESTAMP_DAYS
 * @throws cudf::logic_error if input column datatype is not TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column last_day_of_month(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column last_day_of_month(
  @Const @ByRef column_view column);

/**
 * \brief  Computes the day number since the start of the year from the datetime and
 * returns an int16_t cudf::column. The value is between [1, {365-366}]
 *
 * @param cudf [in] ::column_view of the input datetime values
 *
 * @return cudf::column of datatype INT16 containing the day number since the start of the year.
 * @throws cudf::logic_error if input column datatype is not a TIMESTAMP
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column day_of_year(
  @Const @ByRef column_view column,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column day_of_year(
  @Const @ByRef column_view column);

/**
 * \brief  Adds or subtracts a number of months from the date time type and returns a
 * timestamp column that is of the same type as the input {@code timestamps} column.
 *
 * For a given row, if the {@code timestamps} or the {@code months} column value is null,
 * the output for that row is null.
 * This method preserves the input time and the day where applicable. The date is rounded
 * down to the last day of the month for that year, if the new day is invalid for that month.
 *
 * <pre>{@code {.pseudo}
 * Example:
 * timestamps = [5/31/20 08:00:00, 5/31/20 00:00:00, 5/31/20 13:00:00, 5/31/20 23:00:00,
 *               6/30/20 00:00:01, 6/30/20 14:12:13]
 * months     = [1               , -1              , -3              , -15             ,
 *               -1              , 1]
 * r = add_calendrical_months(timestamp_column, months_column)
 * r is [6/30/20 08:00:00, 4/30/20 00:00:00, 2/29/20 13:00:00, 2/28/19 23:00:00,
 *       5/30/20 00:00:01, 7/30/20 14:12:13]
 * }</pre>
 <p>
 * @param timestamps [in] cudf::column_view of timestamp type.
 * @param months [in] cudf::column_view of integer type containing the number of months to add.
 *
 * @return cudf::column of timestamp type containing the computed timestamps.
 * @throws cudf::logic_error if {@code timestamps} datatype is not a TIMESTAMP or if {@code months} datatype
 * is not INT16.
 * @throws cudf::logic_error if {@code timestamps} column size is not equal to {@code months} column size.
 */
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column add_calendrical_months(
  @Const @ByRef column_view timestamps,
  @Const @ByRef column_view months,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf::datetime") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column add_calendrical_months(
  @Const @ByRef column_view timestamps,
  @Const @ByRef column_view months);
/** \} */  // end of group
  // namespace datetime
  // namespace cudf


// Parsed from cudf/filling.hpp

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.hpp>

// #include <memory>
/**
 * \addtogroup transformation_fill
 * \{
 * \file
 * \brief Column APIs for fill, repeat, and sequence
 */

/**
 * \brief Fills a range of elements in-place in a column with a scalar value.
 *
 * Fills N elements of \p destination starting at \p begin with \p value, where
 * N = (\p end - \p begin).
 *
 * Overwrites the range of elements in \p destination indicated by the indices
 * [\p begin, \p end) with \p value. Use the out-of-place fill function
 * returning std::unique_ptr<column> for use cases requiring memory
 * reallocation.
 *
 * @throws cudf::logic_error if memory reallocation is required (e.g. for
 * variable width types).
 * @throws cudf::logic_error for invalid range (if \p begin < 0,
 * \p begin > \p end, or \p end > \p destination.size()).
 * @throws cudf::logic_error if \p destination and \p value have different
 * types.
 * @throws cudf::logic_error if \p value is invalid but \p destination is not
 * nullable.
 *
 * @param destination The preallocated column to fill into
 * @param begin The starting index of the fill range (inclusive)
 * @param end The index of the last element in the fill range (exclusive)
 * @param value The scalar value to fill
 * @return void
 */
@Namespace("cudf") public static native void fill_in_place(@ByRef mutable_column_view destination,
                   @ByVal IntPointer begin,
                   @ByVal IntPointer end,
                   @Const @ByRef scalar value);

/**
 * \brief Fills a range of elements in a column out-of-place with a scalar
 * value.
 *
 * Creates a new column as-if an in-place fill was performed into \p input;
 * i.e. it is as if a copy of \p input was created first and then the elements
 * indicated by the indices [\p begin, \p end) were overwritten by \p value.
 *
 * @throws cudf::logic_error for invalid range (if \p begin < 0,
 * \p begin > \p end, or \p end > \p destination.size()).
 * @throws cudf::logic_error if \p destination and \p value have different
 * types.
 *
 * @param input The input column used to create a new column. The new column
 * is created by replacing the values of \p input in the specified range with
 * \p value.
 * @param begin The starting index of the fill range (inclusive)
 * @param end The index of the last element in the fill range (exclusive)
 * @param value The scalar value to fill
 * @param mr Device memory resource used to allocate the returned column's device memory
 * @return The result output column
 */
@Namespace("cudf") public static native @UniquePtr @Name("fill") column _fill(
  @Const @ByRef column_view input,
  @ByVal IntPointer begin,
  @ByVal IntPointer end,
  @Const @ByRef scalar value,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Name("fill") column _fill(
  @Const @ByRef column_view input,
  @ByVal IntPointer begin,
  @ByVal IntPointer end,
  @Const @ByRef scalar value);

/**
 * \brief Repeat rows of a Table.
 *
 * Creates a new table by repeating the rows of \p input_table. The number of
 * repetitions of each element is defined by the value at the corresponding
 * index of \p count
 * Example:
 * <pre>{@code
 * in = [4,5,6]
 * count = [1,2,3]
 * return = [4,5,5,6,6,6]
 * }</pre>
 * \p count should not have null values; should not contain negative values;
 * and the sum of count elements should not overflow the size_type's limit.
 * It is undefined behavior if \p count has negative values or the sum overflows
 * and \p check_count is set to false.
 *
 * @throws cudf::logic_error if the data type of \p count is not size_type.
 * @throws cudf::logic_error if \p input_table and \p count have different
 * number of rows.
 * @throws cudf::logic_error if \p count has null values.
 * @throws cudf::logic_error if \p check_count is set to true and \p count
 * has negative values or the sum of \p count elements overflows.
 *
 * @param input_table Input table
 * @param count Non-nullable column of an integral type
 * @param check_count Whether to check count (negative values and overflow)
 * @param mr Device memory resource used to allocate the returned table's device memory
 * @return The result table containing the repetitions
 */
@Namespace("cudf") public static native @UniquePtr table repeat(
  @Const @ByRef table_view input_table,
  @Const @ByRef column_view count,
  @Cast("bool") boolean check_count/*=false*/,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr table repeat(
  @Const @ByRef table_view input_table,
  @Const @ByRef column_view count);

/**
 * \brief Repeat rows of a Table.
 *
 * Creates a new table by repeating \p count times the rows of \p input_table.
 * Example:
 * <pre>{@code
 * in = [4,5,6]
 * count = 2
 * return = [4,4,5,5,6,6]
 * }</pre>
 * @throws cudf::logic_error if the data type of \p count is not size_type.
 * @throws cudf::logic_error if \p count is invalid or \p count is negative.
 * @throws cudf::logic_error if \p input_table.num_rows() * \p count overflows
 * size_type.
 *
 * @param input_table Input table
 * @param count Number of repetitions
 * @param mr Device memory resource used to allocate the returned table's device memory.
 * @return The result table containing the repetitions
 */
@Namespace("cudf") public static native @UniquePtr table repeat(
  @Const @ByRef table_view input_table,
  @ByVal IntPointer count,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr table repeat(
  @Const @ByRef table_view input_table,
  @ByVal IntPointer count);

/**
 * \brief Fills a column with a sequence of value specified by an initial value and a step.
 *
 * Creates a new column and fills with \p size values starting at \p init and
 * incrementing by \p step, generating the sequence
 * [ init, init+step, init+2*step, ... init + (size - 1)*step]
 *
 * <pre>{@code
 * size = 3
 * init = 0
 * step = 2
 * return = [0, 2, 4]
 * }</pre>
 * @throws cudf::logic_error if \p init and \p \step are not the same type.
 * @throws cudf::logic_error if scalar types are not numeric.
 * @throws cudf::logic_error if \p size is < 0.
 *
 * @param size Size of the output column
 * @param init First value in the sequence
 * @param step Increment value
 * @param mr Device memory resource used to allocate the returned column's device memory
 * @return std::unique_ptr<column> The result table containing the sequence
 **/
@Namespace("cudf") public static native @UniquePtr column sequence(
  @ByVal IntPointer size,
  @Const @ByRef scalar init,
  @Const @ByRef scalar step,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr column sequence(
  @ByVal IntPointer size,
  @Const @ByRef scalar init,
  @Const @ByRef scalar step);

/**
 * \brief Fills a column with a sequence of value specified by an initial value and a step of 1.
 *
 * Creates a new column and fills with \p size values starting at \p init and
 * incrementing by 1, generating the sequence
 * [ init, init+1, init+2, ... init + (size - 1)]
 *
 * <pre>{@code
 * size = 3
 * init = 0
 * return = [0, 1, 2]
 * }</pre>
 * @throws cudf::logic_error if \p init is not numeric.
 * @throws cudf::logic_error if \p size is < 0.
 *
 * @param size Size of the output column
 * @param init First value in the sequence
 * @param mr Device memory resource used to allocate the returned column's device memory
 * @return std::unique_ptr<column> The result table containing the sequence
 **/
@Namespace("cudf") public static native @UniquePtr column sequence(
  @ByVal IntPointer size,
  @Const @ByRef scalar init,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr column sequence(
  @ByVal IntPointer size,
  @Const @ByRef scalar init);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/hashing.hpp

/*
 * Copyright (c) 2019-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/table/table.hpp>
// #include <cudf/table/table_view.hpp>
/**
 * \addtogroup column_hash
 * \{
 * \file
 */

/**
 * \brief Computes the hash value of each row in the input set of columns.
 *
 * @param input The table of columns to hash
 * @param initial_hash Optional vector of initial hash values for each column.
 * If this vector is empty then each element will be hashed as-is.
 * @param mr Device memory resource used to allocate the returned column's device memory.
 *
 * @return A column where each row is the hash of a column from the input
 */
@Namespace("cudf") public static native @UniquePtr column hash(
  @Const @ByRef table_view input,
  @ByVal(nullValue = "hash_id::HASH_MURMUR3") hash_id hash_function,
  @Cast("uint32_t*") @StdVector IntPointer initial_hash/*={}*/,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr column hash(
  @Const @ByRef table_view input);
@Namespace("cudf") public static native @UniquePtr column hash(
  @Const @ByRef table_view input,
  @ByVal(nullValue = "hash_id::HASH_MURMUR3") hash_id hash_function,
  @Cast("uint32_t*") @StdVector IntBuffer initial_hash/*={}*/,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr column hash(
  @Const @ByRef table_view input,
  @ByVal(nullValue = "hash_id::HASH_MURMUR3") hash_id hash_function,
  @Cast("uint32_t*") @StdVector int[] initial_hash/*={}*/,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/transpose.hpp

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/column/column.hpp>
// #include <cudf/table/table_view.hpp>
/**
 * \addtogroup reshape_transpose
 * \{
 * \file
 */

/**
 * \brief Transposes a table.
 *
 * Stores output in a contiguous column, exposing the transposed table as
 * a {@code table_view}.
 *
 * @throws cudf::logic_error if column types are non-homogenous
 * @throws cudf::logic_error if column types are non-fixed-width
 *
 * @param input [in] A table (M cols x N rows) to be transposed.
 * @return          The transposed input (N cols x M rows) as a {@code column} and
 *                  {@code table_view}, representing the owner and transposed table,
 *                  respectively.
 */
@Namespace("cudf") public static native @ByVal PairColumnTableView transpose(
  @Const @ByRef table_view input,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @ByVal PairColumnTableView transpose(
  @Const @ByRef table_view input);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/column/column.hpp

/*
 * Copyright (c) 2019-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/column/column_view.hpp>

// #include <cudf/null_mask.hpp>
// #include <cudf/types.hpp>

// #include <rmm/cuda_stream_view.hpp>
// #include <rmm/device_buffer.hpp>

// #include <memory>
// #include <type_traits>
// #include <utility>
// #include <vector>

/**
 * \file
 * \brief Class definition for cudf::column
 */
// Targeting ../column.java



/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/column/column_factories.hpp

/*
 * Copyright (c) 2019-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/column/column.hpp>
// #include <cudf/types.hpp>
// #include <cudf/utilities/traits.hpp>

// #include <rmm/thrust_rmm_allocator.h>
// #include <rmm/cuda_stream_view.hpp>
/**
 * \addtogroup column_factories
 * \{
 * \file
 * \brief Column factory APIs
 */

/**
 * \brief Creates an empty column of the specified \p type
 *
 * An empty column contains zero elements and no validity mask.
 *
 * @param type [in] The column data type
 * @return Empty column with desired type
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_empty_column(@ByVal data_type type);

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified numeric {@code data_type} with an optional
 * null mask.
 *
 * \note {@code null_count()} is determined by the requested null mask {@code state}
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a numeric type
 *
 * @param type [in] The desired numeric element type
 * @param size [in] The number of elements in the column
 * @param state [in] Optional, controls allocation/initialization of the
 * column's null mask. By default, no null mask is allocated.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_numeric_column(
  @ByVal data_type type,
  @ByVal IntPointer size,
  @ByVal(nullValue = "mask_state::UNALLOCATED") mask_state state,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_numeric_column(
  @ByVal data_type type,
  @ByVal IntPointer size);

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified numeric {@code data_type} with a
 * null mask.
 *
 * \note null_count is optional and will be computed if not provided.
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a numeric type
 *
 * @param type [in] The desired numeric element type
 * @param size [in] The number of elements in the column
 * @param null_mask [in] Null mask to use for this column.
 * @param null_count [in] Optional number of nulls in the null_mask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */

/**
 * \brief Construct column with sufficient uninitialized storage to hold {@code size} elements of the
 * specified {@code fixed_point} {@code data_type} with an optional null mask.
 *
 * \note The column's null count is determined by the requested null mask {@code state}.
 *
 * @throws cudf::logic_error if {@code type} is not a {@code fixed_point} type.
 *
 * @param type [in] The desired {@code fixed_point} element type.
 * @param size [in] The number of elements in the column.
 * @param state [in] Optional, controls allocation/initialization of the.
 * column's null mask. By default, no null mask is allocated.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_fixed_point_column(
  @ByVal data_type type,
  @ByVal IntPointer size,
  @ByVal(nullValue = "mask_state::UNALLOCATED") mask_state state,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_fixed_point_column(
  @ByVal data_type type,
  @ByVal IntPointer size);

/**
 * \brief Construct column with sufficient uninitialized storage to hold {@code size} elements of the
 * specified {@code fixed_point} {@code data_type} with a null mask.
 *
 * \note null_count is optional and will be computed if not provided.
 *
 * @throws cudf::logic_error if {@code type} is not a {@code fixed_point} type.
 *
 * @param type [in] The desired {@code fixed_point} element type.
 * @param size [in] The number of elements in the column.
 * @param null_mask [in] Null mask to use for this column.
 * @param null_count [in] Optional number of nulls in the null_mask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory.
 */

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified timestamp {@code data_type} with an
 * optional null mask.
 *
 * \note {@code null_count()} is determined by the requested null mask {@code state}
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a timestamp type
 *
 * @param type [in] The desired timestamp element type
 * @param size [in] The number of elements in the column
 * @param state [in] Optional, controls allocation/initialization of the
 * column's null mask. By default, no null mask is allocated.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_timestamp_column(
  @ByVal data_type type,
  @ByVal IntPointer size,
  @ByVal(nullValue = "mask_state::UNALLOCATED") mask_state state,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_timestamp_column(
  @ByVal data_type type,
  @ByVal IntPointer size);

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified timestamp {@code data_type} with a
 * null mask.
 *
 * \note null_count is optional and will be computed if not provided.
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a timestamp type
 *
 * @param type [in] The desired timestamp element type
 * @param size [in] The number of elements in the column
 * @param null_mask [in] Null mask to use for this column.
 * @param null_count [in] Optional number of nulls in the null_mask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified duration {@code data_type} with an
 * optional null mask.
 *
 * \note {@code null_count()} is determined by the requested null mask {@code state}
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a duration type
 *
 * @param type [in] The desired duration element type
 * @param size [in] The number of elements in the column
 * @param state [in] Optional, controls allocation/initialization of the
 * column's null mask. By default, no null mask is allocated.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_duration_column(
  @ByVal data_type type,
  @ByVal IntPointer size,
  @ByVal(nullValue = "mask_state::UNALLOCATED") mask_state state,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_duration_column(
  @ByVal data_type type,
  @ByVal IntPointer size);

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified duration {@code data_type} with a
 * null mask.
 *
 * \note null_count is optional and will be computed if not provided.
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a duration type
 *
 * @param type [in] The desired duration element type
 * @param size [in] The number of elements in the column
 * @param null_mask [in] Null mask to use for this column.
 * @param null_count [in] Optional number of nulls in the null_mask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified fixed width {@code data_type} with an optional
 * null mask.
 *
 * \note {@code null_count()} is determined by the requested null mask {@code state}
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a fixed width type
 *
 * @param type [in] The desired fixed width type
 * @param size [in] The number of elements in the column
 * @param state [in] Optional, controls allocation/initialization of the
 * column's null mask. By default, no null mask is allocated.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_fixed_width_column(
  @ByVal data_type type,
  @ByVal IntPointer size,
  @ByVal(nullValue = "mask_state::UNALLOCATED") mask_state state,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_fixed_width_column(
  @ByVal data_type type,
  @ByVal IntPointer size);

/**
 * \brief Construct column with sufficient uninitialized storage
 * to hold {@code size} elements of the specified fixed width {@code data_type} with a
 * null mask.
 *
 * \note null_count is optional and will be computed if not provided.
 *
 * @throws std::bad_alloc if device memory allocation fails
 * @throws cudf::logic_error if {@code type} is not a fixed width type
 *
 * @param type [in] The desired fixed width element type
 * @param size [in] The number of elements in the column
 * @param null_mask [in] Null mask to use for this column.
 * @param null_count [in] Optional number of nulls in the null_mask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory
 */

/**
 * \brief Construct STRING type column given a device vector of pointer/size pairs.
 * The total number of char bytes must not exceed the maximum size of size_type.
 * The string characters are expected to be UTF-8 encoded sequence of char
 * bytes. Use the strings_column_view class to perform strings operations on
 * this type of column.
 *
 * \note {@code null_count()} and {@code null_bitmask} are determined if a pair contains
 * a null string. That is, for each pair, if {@code .first} is null, that string
 * is considered null. Likewise, a string is considered empty (not null)
 * if {@code .first} is not null and {@code .second} is 0. Otherwise the {@code .first} member
 * must be a valid device address pointing to {@code .second} consecutive bytes.
 *
 * @throws std::bad_alloc if device memory allocation fails
 *
 * @param strings [in] The vector of pointer/size pairs.
 *                Each pointer must be a device memory address or {@code nullptr}
 * (indicating a null string). The size must be the number of bytes.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used for allocation of the column's {@code null_mask} and children
 * columns' device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<thrust::pair<const char*,cudf::size_type> > strings,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<thrust::pair<const char*,cudf::size_type> > strings);

/**
 * \brief Construct STRING type column given a device vector of string_view.
 * The total number of char bytes must not exceed the maximum size of size_type.
 * The string characters are expected to be UTF-8 encoded sequence of char
 * bytes. Use the strings_column_view class to perform strings operations on
 * this type of column.
 *
 * \note For each string_view, if {@code .data()} is {@code null_placeholder.data()}, that
 * string is considered null. Likewise, a string is considered empty (not null)
 * if {@code .data()} is not {@code null_placeholder.data()} and {@code .size_bytes()} is 0.
 * Otherwise the {@code .data()} must be a valid device address pointing to
 * {@code .size_bytes()} consecutive bytes. The {@code null_count()} for the output column
 * will be equal to the number of input {@code string_view}s that are null.
 *
 * @throws std::bad_alloc if device memory allocation fails
 *
 * @param string_views [in] The vector of string_view.
 *                Each string_view must point to a device memory address or
 * {@code null_placeholder} (indicating a null string). The size must be the number of
 * bytes.
 * @param null_placeholder [in] string_view indicating null string in given list of
 * string_views.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used for allocation of the column's {@code null_mask} and children
 * columns' device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<string_view> string_views,
  @Const @ByVal string_view null_placeholder,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<string_view> string_views,
  @Const @ByVal string_view null_placeholder);

/**
 * \brief Construct STRING type column given a device vector of chars
 * encoded as UTF-8, a device vector of byte offsets identifying individual
 * strings within the char vector, and an optional null bitmask.
 *
 * {@code offsets.front()} must always be zero.
 *
 * The total number of char bytes must not exceed the maximum size of size_type.
 * Use the strings_column_view class to perform strings operations on this type
 * of column.
 * This function makes a deep copy of the strings, offsets, null_mask to create
 * a new column.
 *
 * @throws std::bad_alloc if device memory allocation fails
 *
 * @param strings [in] The vector of chars in device memory.
 *                This char vector is expected to be UTF-8 encoded characters.
 * @param offsets [in] The vector of byte offsets in device memory.
 *                The number of elements is one more than the total number
 *                of strings so the {@code offsets.back()} is the total
 *                number of bytes in the strings array.
 *                {@code offsets.front()} must always be 0 to point to the beginning
 *                of {@code strings}.
 * @param null_mask [in] Device vector containing the null element indicator bitmask.
 *                  Arrow format for nulls is used for interpeting this bitmask.
 * @param null_count [in] The number of null string entries. If equal to
 * {@code UNKNOWN_NULL_COUNT}, the null count will be computed dynamically on the
 * first invocation of {@code column::null_count()}
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used for allocation of the column's {@code null_mask} and children
 * columns' device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<char> strings,
  @Const @ByRef rmm::device_vector<cudf::size_type> offsets,
  @Const @ByRef(nullValue = "rmm::device_vector<bitmask_type>({})") rmm::device_vector<bitmask_type> null_mask,
  @ByVal(nullValue = "cudf::size_type(cudf::UNKNOWN_NULL_COUNT)") IntPointer null_count,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Const @ByRef rmm::device_vector<char> strings,
  @Const @ByRef rmm::device_vector<cudf::size_type> offsets);

/**
 * \brief Construct STRING type column given a host vector of chars
 * encoded as UTF-8, a host vector of byte offsets identifying individual
 * strings within the char vector, and an optional null bitmask.
 *
 * {@code offsets.front()} must always be zero.
 *
 * The total number of char bytes must not exceed the maximum size of size_type.
 * Use the strings_column_view class to perform strings operations on this type
 * of column.
 * This function makes a deep copy of the strings, offsets, null_mask to create
 * a new column.
 *
 * @throws std::bad_alloc if device memory allocation fails
 *
 * @param strings [in] The contiguous array of chars in host memory.
 *                This char array is expected to be UTF-8 encoded characters.
 * @param offsets [in] The array of byte offsets in host memory.
 *                The number of elements is one more than the total number
 *                of strings so the {@code offsets.back()} is the total
 *                number of bytes in the strings array.
 *                {@code offsets.front()} must always be 0 to point to the beginning
 *                of {@code strings}.
 * @param null_mask [in] Host vector containing the null element indicator bitmask.
 *                  Arrow format for nulls is used for interpeting this bitmask.
 * @param null_count [in] The number of null string entries. If equal to
 * {@code UNKNOWN_NULL_COUNT}, the null count will be computed dynamically on the
 * first invocation of {@code column::null_count()}
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used for allocation of the column's {@code null_mask} and children
 * columns' device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector BytePointer strings,
  @StdVector IntPointer offsets,
  @StdVector bitmask_type null_mask/*={}*/,
  @ByVal(nullValue = "cudf::size_type(cudf::UNKNOWN_NULL_COUNT)") IntPointer null_count,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector BytePointer strings,
  @StdVector IntPointer offsets);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector ByteBuffer strings,
  @StdVector IntPointer offsets,
  @StdVector bitmask_type null_mask/*={}*/,
  @ByVal(nullValue = "cudf::size_type(cudf::UNKNOWN_NULL_COUNT)") IntPointer null_count,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector ByteBuffer strings,
  @StdVector IntPointer offsets);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector byte[] strings,
  @StdVector IntPointer offsets,
  @StdVector bitmask_type null_mask/*={}*/,
  @ByVal(nullValue = "cudf::size_type(cudf::UNKNOWN_NULL_COUNT)") IntPointer null_count,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @Cast("char*") @StdVector byte[] strings,
  @StdVector IntPointer offsets);

/**
 * \brief Constructs a STRING type column given offsets column, chars columns,
 * and null mask and null count. The columns and mask are moved into the
 * resulting strings column.
 *
 * @param num_strings [in] The number of strings the column represents.
 * @param offsets_column [in] The column of offset values for this column.
 *                       The number of elements is one more than the total number
 *                       of strings so the offset[last] - offset[0] is the total
 *                       number of bytes in the strings vector.
 * @param chars_column [in] The column of char bytes for all the strings for this column.
 *                     Individual strings are identified by the offsets and the
 *                     nullmask.
 * @param null_count [in] The number of null string entries.
 * @param null_mask [in] The bits specifying the null strings in device memory.
 *                  Arrow format for nulls is used for interpeting this bitmask.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used for allocation of the column's {@code null_mask} and children
 * columns' device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @ByVal IntPointer num_strings,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column offsets_column,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column chars_column,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_strings_column(
  @ByVal IntPointer num_strings,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column offsets_column,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column chars_column,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask);

/**
 * \brief Constructs a LIST type column given offsets column, child column,
 * and null mask and null count.
 *
 * The columns and mask are moved into the resulting lists column.
 *
 *
 * List columns are structured similarly to strings columns.  They contain
 * a set of offsets which represents the lengths of the lists in each row, and
 * a "child" column of data that is referenced by the offsets.  Since lists
 * are a nested type, the child column may itself be further nested.
 *
 * When child column at depth N+1 is itself a list, the offsets column at
 * depth N references the offsets column for depth N+1.  When the child column at depth
 * N+1 is a leaf type (int, float, etc), the offsets column at depth N references
 * the data for depth N+1.
 *
 * <pre>{@code {.pseudo}
 * Example:
 * List<int>
 * input:              {{1, 2}, {3, 4, 5}}
 * offsets (depth 0)   {0, 2, 5}
 * data    (depth 0)
 * offsets (depth 1)
 * data    (depth 1)   {1, 2, 3, 4, 5}
 * }</pre>
 *
 * <pre>{@code {.pseudo}
 * Example:
 * List<List<int>>
 * input:              { {{1, 2}}, {{3, 4, 5}, {6, 7}} }
 * offsets (depth 0)   {0, 1, 3}
 * data    (depth 0)
 * offsets (depth 1)   {0, 2, 5, 7}
 * data    (depth 1)
 * offsets (depth 2)
 * data    (depth 1)   {1, 2, 3, 4, 5, 6, 7}
 * }</pre>
 *
 * @param num_lists [in] The number of lists the column represents.
 * @param offsets_column [in] The column of offset values for this column. Each value should
 * represent the starting offset into the child elements that corresponds to the beginning of the
 * row, with the first row starting at 0. The length of row N can be determined by subtracting
 * offsets[N+1] - offsets[N]. The total number of offsets should be 1 longer than the # of rows in
 * the column.
 * @param child_column [in] The column of nested data referenced by the lists represented by the
 *                     offsets_column. Note: the child column may itself be
 *                     further nested.
 * @param null_count [in] The number of null list entries.
 * @param null_mask [in] The bits specifying the null lists in device memory.
 *                  Arrow format for nulls is used for interpeting this bitmask.
 * @param stream [in] Optional stream for use with all memory allocation
 *               and device kernels
 * @param mr [in] Optional resource to use for device memory
 *           allocation of the column's {@code null_mask} and children.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_lists_column(
  @ByVal IntPointer num_lists,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column offsets_column,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column child_column,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_lists_column(
  @ByVal IntPointer num_lists,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column offsets_column,
  @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column child_column,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask);

/**
 * \brief Constructs a STRUCT column using specified child columns as members.
 *
 * Specified child/member columns and null_mask are adopted by resultant
 * struct column.
 *
 * A struct column requires that all specified child columns have the same
 * number of rows. A struct column's row count equals that of any/all
 * of its child columns. A single struct row at any index is comprised of
 * all the individual child column values at the same index, in the order
 * specified in the list of child columns.
 *
 * The specified null mask governs which struct row has a null value. This
 * is orthogonal to the null values of individual child columns.
 *
 * @param num_rows [in] The number of struct values in the struct column.
 * @param child_columns [in] The list of child/members that the struct is comprised of.
 * @param null_count [in] The number of null values in the struct column.
 * @param null_mask [in] The bits specifying the null struct values in the column.
 * @param stream [in] Optional stream for use with all memory allocation and device kernels.
 * @param mr [in] Optional resource to use for device memory allocation.
 *
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_structs_column(
  @ByVal IntPointer num_rows,
  @ByVal VectorUniqueColumnPointer child_columns,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_structs_column(
  @ByVal IntPointer num_rows,
  @ByVal VectorUniqueColumnPointer child_columns,
  @ByVal IntPointer null_count,
  @ByVal device_buffer null_mask);

/**
 * \brief Return a column with size elements that are all equal to the
 * given scalar.
 *
 * The output column will have the same type as {@code s.type()}
 * The output column will contain all null rows if {@code s.invalid()==false}
 * The output column will be empty if {@code size==0}.
 *
 * @param s [in] The scalar to use for values in the column.
 * @param size [in] The number of rows for the output column.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_column_from_scalar(
  @Const @ByRef scalar s,
  @ByVal IntPointer size,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_column_from_scalar(
  @Const @ByRef scalar s,
  @ByVal IntPointer size);

/**
 * \brief Return a dictionary column with size elements that are all equal to the
 * given scalar.
 *
 * The output column will have keys of type {@code s.type()}
 * The output column will be empty if {@code size==0}.
 *
 * @throws cudf::logic_error if {@code s.is_valid()==false}
 *
 * @param s [in] The scalar to use for values in the column.
 * @param size [in] The number of rows for the output column.
 * @param stream [in] CUDA stream used for device memory operations and kernel launches.
 * @param mr [in] Device memory resource used to allocate the returned column's device memory.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_dictionary_from_scalar(
  @Const @ByRef scalar s,
  @ByVal IntPointer size,
  @ByVal(nullValue = "rmm::cuda_stream_view(rmm::cuda_stream_default)") cuda_stream_view stream,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column make_dictionary_from_scalar(
  @Const @ByRef scalar s,
  @ByVal IntPointer size);

/** \} */  // end of group
  // namespace cudf


// Parsed from cudf/column/column_view.hpp

/*
 * Copyright (c) 2019, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// #pragma once

// #include <cudf/types.hpp>
// #include <vector>

/**
 * \file column_view.hpp
 * \brief column view class definitons
 */
// Targeting ../column_view_base.java


// Targeting ../mutable_column_view_base.java



// Targeting ../column_view.java


// Targeting ../mutable_column_view.java



/**
 * \brief Counts the number of descendants of the specified parent.
 *
 * @param parent The parent whose descendants will be counted
 * @return size_type The number of descendants of the parent
 **/
@Namespace("cudf") public static native @ByVal IntPointer count_descendants(@ByVal column_view parent);

/**
 * \brief Zero-copy cast between types with the same underlying representation.
 *
 * This is similar to {@code reinterpret_cast} or {@code bit_cast} in that it gives a view of the same raw bits
 * as a different type. Unlike {@code reinterpret_cast} however, this cast is only allowed on types that
 * have the same width and underlying representation. For example, the way timestamp types are laid
 * out in memory is equivalent to an integer representing a duration since a fixed epoch; logically
 * casting to the same integer type (INT32 for days, INT64 for others) results in a raw view of the
 * duration count. However, an INT32 column cannot be logically cast to INT64 as the sizes differ,
 * nor can an INT32 columm be logically cast to a FLOAT32 since what the bits represent differs.
 *
 * The validity of the conversion can be checked with {@code cudf::is_logically_castable()}.
 *
 * @throws cudf::logic_error if the specified cast is not possible, i.e.,
 * {@code is_logically_castable(input.type(), type)} is false.
 *
 * @param input The {@code column_view} to cast from
 * @param type The {@code data_type} to cast to
 * @return New {@code column_view} wrapping the same data as {@code input} but cast to {@code type}
 */
@Namespace("cudf") public static native @ByVal column_view logical_cast(@Const @ByRef column_view input, @ByVal data_type type);

/**
 * \brief Zero-copy cast between types with the same underlying representation.
 *
 * This is similar to {@code reinterpret_cast} or {@code bit_cast} in that it gives a view of the same raw bits
 * as a different type. Unlike {@code reinterpret_cast} however, this cast is only allowed on types that
 * have the same width and underlying representation. For example, the way timestamp types are laid
 * out in memory is equivalent to an integer representing a duration since a fixed epoch; logically
 * casting to the same integer type (INT32 for days, INT64 for others) results in a raw view of the
 * duration count. However, an INT32 column cannot be logically cast to INT64 as the sizes differ,
 * nor can an INT32 columm be logically cast to a FLOAT32 since what the bits represent differs.
 *
 * The validity of the conversion can be checked with {@code cudf::is_logically_castable()}.
 *
 * @throws cudf::logic_error if the specified cast is not possible, i.e.,
 * {@code is_logically_castable(input.type(), type)} is false.
 *
 * @param input The {@code mutable_column_view} to cast from
 * @param type The {@code data_type} to cast to
 * @return New {@code mutable_column_view} wrapping the same data as {@code input} but cast to {@code type}
 */
@Namespace("cudf") public static native @ByVal mutable_column_view logical_cast(@Const @ByRef mutable_column_view input, @ByVal data_type type);

  // namespace cudf


// Parsed from cudf/types.hpp

/*
 * Copyright (c) 2018-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #ifdef __CUDACC__
// #define CUDA_HOST_DEVICE_CALLABLE __host__ __device__ inline
// #define CUDA_DEVICE_CALLABLE __device__ inline
// #else
// #define CUDA_HOST_DEVICE_CALLABLE inline
// #define CUDA_DEVICE_CALLABLE inline
// #endif

// #include <thrust/optional.h>  // TODO no idea why this is needed ¯\_(ツ)_/¯

// #include <cassert>
// #include <cstddef>
// #include <cstdint>
// #include <iterator>

/**
 * \file
 * \brief Type declarations for libcudf.
 *
 **/

// Targeting ../device_buffer.java


// Targeting ../device_memory_resource.java


@Namespace("rmm::mr") public static native device_memory_resource get_current_device_resource();
  // namespace mr

  // namespace rmm
// Targeting ../string_view.java


// Targeting ../list_view.java


// Targeting ../struct_view.java


// Targeting ../scalar.java


// Targeting ../list_scalar.java


// Targeting ../string_scalar.java


// Targeting ../string_scalar_device_view.java


// Targeting ../struct_scalar.java


// Targeting ../table.java


// Targeting ../table_view.java


// Targeting ../mutable_table_view.java



/**
 * \addtogroup utility_types
 * \{
 * \file
 */

/**
 * \brief Similar to {@code std::distance} but returns {@code cudf::size_type} and performs {@code static_cast}
 *
 * \tparam T Iterator type
 * @param f "first" iterator
 * @param l "last" iterator
 * @return size_type The distance between first and last
 */

/**
 * \brief Indicates an unknown null count.
 *
 * Use this value when constructing any column-like object to indicate that
 * the null count should be computed on the first invocation of {@code null_count()}.
 **/
@Namespace("cudf") @MemberGetter public static native @Const @ByRef IntPointer UNKNOWN_NULL_COUNT();

/**
 * \brief Indicates the order in which elements should be sorted.
 **/
@Namespace("cudf") public enum order {
  /** Elements ordered from small to large */
  ASCENDING(0 != 0),
  /** Elements ordered from large to small */
  DESCENDING(1 != 0);

    public final boolean value;
    private order(boolean v) { this.value = v; }
    private order(order e) { this.value = e.value; }
    public order intern() { for (order e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Enum to specify whether to include nulls or exclude nulls
 */
@Namespace("cudf") public enum null_policy {
  /** exclude null elements */
  EXCLUDE(0 != 0),
  /** include null elements */
  INCLUDE(1 != 0);

    public final boolean value;
    private null_policy(boolean v) { this.value = v; }
    private null_policy(null_policy e) { this.value = e.value; }
    public null_policy intern() { for (null_policy e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Enum to treat NaN floating point value as null or non-null element
 */
@Namespace("cudf") public enum nan_policy {
  /** treat nans as null elements */
  NAN_IS_NULL(0 != 0),
  /** treat nans as valid elements (non-null) */
  NAN_IS_VALID(1 != 0);

    public final boolean value;
    private nan_policy(boolean v) { this.value = v; }
    private nan_policy(nan_policy e) { this.value = e.value; }
    public nan_policy intern() { for (nan_policy e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief
 */
@Namespace("cudf") public enum null_equality {
  /** nulls compare equal */
  EQUAL(0 != 0),
  /** nulls compare unequal */
  UNEQUAL(1 != 0);

    public final boolean value;
    private null_equality(boolean v) { this.value = v; }
    private null_equality(null_equality e) { this.value = e.value; }
    public null_equality intern() { for (null_equality e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Indicates how null values compare against all other values.
 **/
@Namespace("cudf") public enum null_order {
  /** NULL values ordered *after* all other values */
  AFTER(0 != 0),
  /** NULL values ordered *before* all other values */
  BEFORE(1 != 0);

    public final boolean value;
    private null_order(boolean v) { this.value = v; }
    private null_order(null_order e) { this.value = e.value; }
    public null_order intern() { for (null_order e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Indicates whether a collection of values is known to be sorted.
 */
@Namespace("cudf") public enum sorted { NO(0 != 0), YES(1 != 0);

    public final boolean value;
    private sorted(boolean v) { this.value = v; }
    private sorted(sorted e) { this.value = e.value; }
    public sorted intern() { for (sorted e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting ../order_info.java



/**
 * \brief Controls the allocation/initialization of a null mask.
 **/
@Namespace("cudf") public enum mask_state {
  /** Null mask not allocated, (all elements are valid) */
  UNALLOCATED(0),
  /** Null mask allocated, but not initialized */
  UNINITIALIZED(1),
  /** Null mask allocated, initialized to all elements valid */
  ALL_VALID(2),
  /** Null mask allocated, initialized to all elements NULL */
  ALL_NULL(3);

    public final int value;
    private mask_state(int v) { this.value = v; }
    private mask_state(mask_state e) { this.value = e.value; }
    public mask_state intern() { for (mask_state e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Interpolation method to use when the desired quantile lies between
 * two data points i and j
 */
@Namespace("cudf") public enum interpolation {
  /** Linear interpolation between i and j */
  LINEAR(0),
  /** Lower data point (i) */
  LOWER(1),
  /** Higher data point (j) */
  HIGHER(2),
  /** (i + j)/2 */
  MIDPOINT(3),
  /** i or j, whichever is nearest */
  NEAREST(4);

    public final int value;
    private interpolation(int v) { this.value = v; }
    private interpolation(interpolation e) { this.value = e.value; }
    public interpolation intern() { for (interpolation e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Identifies a column's logical element type
 **/
@Namespace("cudf") public enum type_id {
  /** Always null with no underlying data */
  EMPTY(0),
  /** 1 byte signed integer */
  INT8(1),
  /** 2 byte signed integer */
  INT16(2),
  /** 4 byte signed integer */
  INT32(3),
  /** 8 byte signed integer */
  INT64(4),
  /** 1 byte unsigned integer */
  UINT8(5),
  /** 2 byte unsigned integer */
  UINT16(6),
  /** 4 byte unsigned integer */
  UINT32(7),
  /** 8 byte unsigned integer */
  UINT64(8),
  /** 4 byte floating point */
  FLOAT32(9),
  /** 8 byte floating point */
  FLOAT64(10),
  /** Boolean using one byte per value, 0 == false, else true */
  BOOL8(11),
  /** point in time in days since Unix Epoch in int32 */
  TIMESTAMP_DAYS(12),
  /** point in time in seconds since Unix Epoch in int64 */
  TIMESTAMP_SECONDS(13),
  /** point in time in milliseconds since Unix Epoch in int64 */
  TIMESTAMP_MILLISECONDS(14),
  /** point in time in microseconds since Unix Epoch in int64 */
  TIMESTAMP_MICROSECONDS(15),
  /** point in time in nanoseconds since Unix Epoch in int64 */
  TIMESTAMP_NANOSECONDS(16),
  /** time interval of days in int32 */
  DURATION_DAYS(17),
  /** time interval of seconds in int64 */
  DURATION_SECONDS(18),
  /** time interval of milliseconds in int64 */
  DURATION_MILLISECONDS(19),
  /** time interval of microseconds in int64 */
  DURATION_MICROSECONDS(20),
  /** time interval of nanoseconds in int64 */
  DURATION_NANOSECONDS(21),
  /** Dictionary type using int32 indices */
  DICTIONARY32(22),
  /** String elements */
  STRING(23),
  /** List elements */
  LIST(24),
  /** Fixed-point type with int32_t */
  DECIMAL32(25),
  /** Fixed-point type with int64_t */
  DECIMAL64(26),
  /** Struct elements */
  STRUCT(27),
  // `NUM_TYPE_IDS` must be last!
  /** Total number of type ids */
  NUM_TYPE_IDS(28);

    public final int value;
    private type_id(int v) { this.value = v; }
    private type_id(type_id e) { this.value = e.value; }
    public type_id intern() { for (type_id e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}
// Targeting ../data_type.java



/**
 * \brief Compares two {@code data_type} objects for equality.
 *
 * // TODO Define exactly what it means for two {@code data_type}s to be equal. e.g.,
 * are two timestamps with different resolutions equal? How about decimals with
 * different scale/precision?
 *
 * @param lhs The first {@code data_type} to compare
 * @param rhs The second {@code data_type} to compare
 * @return true {@code lhs} is equal to {@code rhs}
 * @return false {@code lhs} is not equal to {@code rhs}
 */
@Namespace("cudf") public static native @Cast("bool") @Name("operator ==") boolean equals(@Const @ByRef data_type lhs, @Const @ByRef data_type rhs);

/**
 * \brief Compares two {@code data_type} objects for inequality.
 *
 * // TODO Define exactly what it means for two {@code data_type}s to be equal. e.g.,
 * are two timestamps with different resolutions equal? How about decimals with
 * different scale/precision?
 *
 * @param lhs The first {@code data_type} to compare
 * @param rhs The second {@code data_type} to compare
 * @return true {@code lhs} is not equal to {@code rhs}
 * @return false {@code lhs} is equal to {@code rhs}
 */
@Namespace("cudf") public static native @Cast("bool") @Name("operator !=") boolean notEquals(@Const @ByRef data_type lhs, @Const @ByRef data_type rhs);

/**
 * \brief Returns the size in bytes of elements of the specified {@code data_type}
 *
 * \note Only fixed-width types are supported
 *
 * @throws cudf::logic_error if {@code is_fixed_width(element_type) == false}
 *
 * @return Size in bytes of an element of the specified {@code data_type}
 */
@Namespace("cudf") public static native @ByVal @Cast("std::size_t*") SizeTPointer size_of(@ByVal data_type t);

/**
 *  \brief Identifies the hash function to be used
 */
@Namespace("cudf") public enum hash_id {
  /** Identity hash function that simply returns the key to be hashed */
  HASH_IDENTITY(0),
  /** Murmur3 hash function */
  HASH_MURMUR3(1),
  /** MD5 hash function */
  HASH_MD5(2);

    public final int value;
    private hash_id(int v) { this.value = v; }
    private hash_id(hash_id e) { this.value = e.value; }
    public hash_id intern() { for (hash_id e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/** \} */
  // namespace cudf


// Parsed from cudf/unary.hpp

/*
 * Copyright (c) 2018-2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <cudf/types.hpp>
// #include <memory>
/**
 * \addtogroup transformation_unaryops
 * \{
 * \file
 * \brief Column APIs for unary ops
 */

@Namespace("cudf") public enum unary_operator {
  SIN(0),         // < Trigonometric sine
  COS(1),         // < Trigonometric cosine
  TAN(2),         // < Trigonometric tangent
  ARCSIN(3),      // < Trigonometric sine inverse
  ARCCOS(4),      // < Trigonometric cosine inverse
  ARCTAN(5),      // < Trigonometric tangent inverse
  SINH(6),        // < Hyperbolic sine
  COSH(7),        // < Hyperbolic cosine
  TANH(8),        // < Hyperbolic tangent
  ARCSINH(9),     // < Hyperbolic sine inverse
  ARCCOSH(10),     // < Hyperbolic cosine inverse
  ARCTANH(11),     // < Hyperbolic tangent inverse
  EXP(12),         // < Exponential (base e, Euler number)
  LOG(13),         // < Natural Logarithm (base e)
  SQRT(14),        // < Square-root (x^0.5)
  CBRT(15),        // < Cube-root (x^(1.0/3))
  CEIL(16),        // < Smallest integer value not less than arg
  FLOOR(17),       // < largest integer value not greater than arg
  ABS(18),         // < Absolute value
  RINT(19),        // < Rounds the floating-point argument arg to an integer value
  BIT_INVERT(20),  // < Bitwise Not (~)
  NOT(21);        // < Logical Not (!)

    public final int value;
    private unary_operator(int v) { this.value = v; }
    private unary_operator(unary_operator e) { this.value = e.value; }
    public unary_operator intern() { for (unary_operator e : values()) if (e.value == value) return e; return this; }
    @Override public String toString() { return intern().name(); }
}

/**
 * \brief Performs unary op on all values in column
 *
 * Note: For {@code decimal32} and {@code decimal64}, only {@code ABS}, {@code CEIL} and {@code FLOOR} are supported.
 *
 * @param input A {@code column_view} as input
 * @param op operation to perform
 * @param mr Device memory resource used to allocate the returned column's device memory
 *
 * @return Column of same size as {@code input} containing result of the operation
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column unary_operation(
  @Const @ByRef column_view input,
  unary_operator op,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column unary_operation(
  @Const @ByRef column_view input,
  unary_operator op);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column unary_operation(
  @Const @ByRef column_view input,
  @Cast("cudf::unary_operator") int op,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column unary_operation(
  @Const @ByRef column_view input,
  @Cast("cudf::unary_operator") int op);

/**
 * \brief Creates a column of {@code type_id::BOOL8} elements where for every element in {@code input} {@code true}
 * indicates the value is null and {@code false} indicates the value is valid.
 *
 * @param input A {@code column_view} as input
 * @param mr Device memory resource used to allocate the returned column's device memory
 *
 * @return A non-nullable column of {@code type_id::BOOL8} elements with {@code true}
 * representing {@code null} values.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_null(
  @Const @ByRef column_view input,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_null(
  @Const @ByRef column_view input);

/**
 * \brief Creates a column of {@code type_id::BOOL8} elements where for every element in {@code input} {@code true}
 * indicates the value is valid and {@code false} indicates the value is null.
 *
 * @param input A {@code column_view} as input
 * @param mr Device memory resource used to allocate the returned column's device memory
 *
 * @return A non-nullable column of {@code type_id::BOOL8} elements with {@code false}
 * representing {@code null} values.
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_valid(
  @Const @ByRef column_view input,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_valid(
  @Const @ByRef column_view input);

/**
 * \brief  Casts data from dtype specified in input to dtype specified in output.
 *
 * Supports only fixed-width types.
 *
 * @param column_view Input column
 * @param out_type Desired datatype of output column
 * @param mr Device memory resource used to allocate the returned column's device memory
 *
 * @return Column of same size as {@code input} containing result of the cast operation
 * @throws cudf::logic_error if {@code out_type} is not a fixed-width type
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column cast(
  @Const @ByRef column_view input,
  @ByVal data_type out_type,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column cast(
  @Const @ByRef column_view input,
  @ByVal data_type out_type);

/**
 * \brief Creates a column of {@code type_id::BOOL8} elements indicating the presence of {@code NaN} values
 * in a column of floating point values.
 * The output element at row {@code i} is {@code true} if the element in {@code input} at row i is {@code NAN}, else {@code false}
 *
 * @throws cudf::logic_error if {@code input} is a non-floating point type
 *
 * @param input A column of floating-point elements
 * @param mr Device memory resource used to allocate the returned column's device memory.
 *
 * @return A non-nullable column of {@code type_id::BOOL8} elements with {@code true} representing {@code NAN} values
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_nan(
  @Const @ByRef column_view input,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_nan(
  @Const @ByRef column_view input);

/**
 * \brief Creates a column of {@code type_id::BOOL8} elements indicating the absence of {@code NaN} values
 * in a column of floating point values.
 * The output element at row {@code i} is {@code false} if the element in {@code input} at row i is {@code NAN}, else {@code true}
 *
 * @throws cudf::logic_error if {@code input} is a non-floating point type
 *
 * @param input A column of floating-point elements
 * @param mr Device memory resource used to allocate the returned column's device memory.
 *
 * @return A non-nullable column of {@code type_id::BOOL8} elements with {@code false} representing {@code NAN}
 * values
 */
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_not_nan(
  @Const @ByRef column_view input,
  device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
@Namespace("cudf") public static native @UniquePtr @Cast({"", "std::unique_ptr<cudf::column>"}) column is_not_nan(
  @Const @ByRef column_view input);

/** \} */  // end of group
  // namespace cudf


}
