// Targeted by JavaCPP version 1.5.4: DO NOT EDIT THIS FILE

package ai.rapids.cudf.global;

import ai.rapids.rmm.*;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import ai.rapids.thrust.*;
import static ai.rapids.cudf.global.thrust.*;

public class rmm extends ai.rapids.cudf.presets.rmm {
    static { Loader.load(); }

// Parsed from rmm/device_uvector.hpp

/*
 * Copyright (c) 2020, NVIDIA CORPORATION.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// #pragma once

// #include <rmm/cuda_stream_view.hpp>
// #include <rmm/detail/error.hpp>
// #include <rmm/device_buffer.hpp>
// #include <rmm/mr/device/device_memory_resource.hpp>
// #include <rmm/mr/device/per_device_resource.hpp>

// #include <vector>

/**
 * \brief An *uninitialized* vector of elements in device memory.
 *
 * Similar to a {@code thrust::device_vector}, {@code device_uvector} is a random access container of elements
 * stored contiguously in device memory. However, unlike {@code thrust::device_vector}, {@code device_uvector}
 * does *not* default initialize the vector elements.
 *
 * If initialization is desired, this must be done explicitly by the caller, e.g., with
 * {@code thrust::uninitialized_fill}.
 *
 * Example:
 * <pre>{@code
 * rmm::mr::device_memory_resource * mr = new my_custom_resource();
 * rmm::cuda_stream_view s{};
 *
 * // Allocates *uninitialized* device memory on stream `s` sufficient for 100 ints using the
 * // supplied resource `mr`
 * rmm::device_uvector<int> uv(100, s, mr);
 *
 * // Initializes all elements to 0 on stream `s`
 * thrust::uninitialized_fill(thrust::cuda::par.on(s), uv.begin(), uv.end(), 0);
 * }</pre>
 *
 * Avoiding default initialization improves performance by eliminating the kernel launch required to
 * default initialize the elements. This initialization is often unnecessary, e.g., when the vector
 * is created to hold some output from some operation.
 *
 * However, this restricts the element type {@code T} to only trivially copyable types. In short,
 * trivially copyable types can be safely copied with {@code memcpy}. For more information, see
 * https://en.cppreference.com/w/cpp/types/is_trivially_copyable.
 *
 * Another key difference over {@code thrust::device_vector} is that all operations that invoke
 * allocation, kernels, or memcpys take a CUDA stream parameter to indicate on which stream the
 * operation will be performed.
 *
 * \tparam T Trivially copyable element type
 */
  // namespace rmm


}
