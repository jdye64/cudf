// Targeted by JavaCPP version 1.5.4: DO NOT EDIT THIS FILE

package ai.rapids.cudf;

import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;

import static ai.rapids.cudf.global.cudf.*;


/**
 * \brief Groups values by keys and computes aggregations on those groups.
 */
@Namespace("cudf::groupby") @NoOffset @Properties(inherit = ai.rapids.cudf.presets.Cudf.class)
public class groupby extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public groupby(Pointer p) { super(p); }

  
  
  
  
  

  /**
   * \brief Construct a groupby object with the specified {@code keys}
   *
   * If the {@code keys} are already sorted, better performance may be achieved by
   * passing {@code keys_are_sorted == true} and indicating the  ascending/descending
   * order of each column and null order in  {@code column_order} and
   * {@code null_precedence}, respectively.
   *
   * \note This object does *not* maintain the lifetime of {@code keys}. It is the
   * user's responsibility to ensure the {@code groupby} object does not outlive the
   * data viewed by the {@code keys} {@code table_view}.
   *
   * @param keys Table whose rows act as the groupby keys
   * @param null_handling Indicates whether rows in {@code keys} that contain
   * NULL values should be included
   * @param keys_are_sorted Indicates whether rows in {@code keys} are already sorted
   * @param column_order If {@code keys_are_sorted == YES}, indicates whether each
   * column is ascending/descending. If empty, assumes all  columns are
   * ascending. Ignored if {@code keys_are_sorted == false}.
   * @param null_precedence If {@code keys_are_sorted == YES}, indicates the ordering
   * of null values in each column. Else, ignored. If empty, assumes all columns
   * use {@code null_order::BEFORE}. Ignored if {@code keys_are_sorted == false}.
   */
  public groupby(@Const @ByRef table_view keys,
                     @ByVal(nullValue = "null_policy::EXCLUDE") null_policy null_handling,
                     @ByVal(nullValue = "sorted::NO") sorted keys_are_sorted,
                     @StdVector order column_order/*={}*/,
                     @StdVector null_order null_precedence/*={}*/) { super((Pointer)null); allocate(keys, null_handling, keys_are_sorted, column_order, null_precedence); }
  private native void allocate(@Const @ByRef table_view keys,
                     @ByVal(nullValue = "null_policy::EXCLUDE") null_policy null_handling,
                     @ByVal(nullValue = "sorted::NO") sorted keys_are_sorted,
                     @StdVector order column_order/*={}*/,
                     @StdVector null_order null_precedence/*={}*/);
  public groupby(@Const @ByRef table_view keys) { super((Pointer)null); allocate(keys); }
  private native void allocate(@Const @ByRef table_view keys);

  /**
   * \brief Performs grouped aggregations on the specified values.
   *
   * The values to aggregate and the aggregations to perform are specifed in an
   * {@code aggregation_request}. Each request contains a {@code column_view} of values to
   * aggregate and a set of {@code aggregation}s to perform on those elements.
   *
   * For each {@code aggregation} in a request, {@code values[i]} is aggregated with
   * all other {@code values[j]} where rows {@code i} and {@code j} in {@code keys} are equivalent.
   *
   * The {@code size()} of the request column must equal {@code keys.num_rows()}.
   *
   * For every {@code aggregation_request} an {@code aggregation_result} will be returned.
   * The {@code aggregation_result} holds the resulting column(s) for each requested
   * aggregation on the {@code request}s values. The order of the columns in each
   * result is the same order as was specified in the request.
   *
   * The returned {@code table} contains the group labels for each group, i.e., the
   * unique rows from {@code keys}. Element {@code i} across all aggregation results
   * belongs to the group at row {@code i} in the group labels table.
   *
   * The order of the rows in the group labels is arbitrary. Furthermore,
   * successive {@code groupby::aggregate} calls may return results in different
   * orders.
   *
   * @throws cudf::logic_error If {@code requests[i].values.size() !=
   * keys.num_rows()}.
   *
   * Example:
   * <pre>{@code
   * Input:
   * keys:     {1 2 1 3 1}
   *           {1 2 1 4 1}
   * request:
   *   values: {3 1 4 9 2}
   *   aggregations: {{SUM}, {MIN}}
   *
   * result:
   *
   * keys:  {3 1 2}
   *        {4 1 2}
   * values:
   *   SUM: {9 9 1}
   *   MIN: {9 2 1}
   * }</pre>
   *
   * @param requests The set of columns to aggregate and the aggregations to
   * perform
   * @param mr Device memory resource used to allocate the returned table and columns' device memory
   * @return Pair containing the table with each group's unique key and
   * a vector of aggregation_results for each request in the same order as
   * specified in {@code requests}.
   */
  public native @ByVal std::pair<std::unique_ptr<table>,std::vector<cudf::groupby::aggregation_result> > aggregate(
      @StdVector aggregation_request requests,
      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
  public native @ByVal std::pair<std::unique_ptr<table>,std::vector<cudf::groupby::aggregation_result> > aggregate(
      @StdVector aggregation_request requests);

  /**
   * \brief The grouped data corresponding to a groupby operation on a set of values.
   *
   * A {@code groups} object holds two tables of identical number of rows:
   * a table of grouped keys and a table of grouped values. In addition, it holds
   * a vector of integer offsets into the rows of the tables, such that
   * {@code offsets[i+1] - offsets[i]} gives the size of group {@code i}.
   */
  public static class groups extends Pointer {
      static { Loader.load(); }
      /** Default native constructor. */
      public groups() { super((Pointer)null); allocate(); }
      /** Native array allocator. Access with {@link Pointer#position(long)}. */
      public groups(long size) { super((Pointer)null); allocateArray(size); }
      /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
      public groups(Pointer p) { super(p); }
      private native void allocate();
      private native void allocateArray(long size);
      @Override public groups position(long position) {
          return (groups)super.position(position);
      }
      @Override public groups getPointer(long i) {
          return new groups(this).position(position + i);
      }
  
    public native @UniquePtr table keys(); public native groups keys(table setter);
    public native @StdVector size_type offsets(); public native groups offsets(size_type setter);
    public native @UniquePtr table values(); public native groups values(table setter);
  }

  /**
   * \brief Get the grouped keys and values corresponding to a groupby operation on a set of values
   *
   * Returns a {@code groups} object representing the grouped keys and values.
   * If values is not provided, only a grouping of the keys is performed,
   * and the {@code values} of the {@code groups} object will be {@code nullptr}.
   *
   * @param values Table representing values on which a groupby operation is to be performed
   * @param mr Device memory resource used to allocate the returned tables's device memory in the
   * returned groups
   * @return A {@code groups} object representing grouped keys and values
   */
  public native @ByVal groups get_groups(@ByVal(nullValue = "cudf::table_view({})") table_view values,
                      device_memory_resource mr/*=rmm::mr::get_current_device_resource()*/);
  public native @ByVal groups get_groups();
}
